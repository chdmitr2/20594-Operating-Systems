Programming task(80%):

code & run: 
Well Done

theoretical task(20%):
2 (5%) ok
3 (5%) ok
4 (5%) ok
5 (5%) ok

==============================================================================================================



Answers:
=====================
Question 1
=====================	
Example of the unsafe state table as shown in the book (fig 3-10).
The resource, for example can be buffers needed to complete a print prepare job.

  HAS MAX
A  4   9
B  2   4
C  2   7

The scheduler could run B until it asked for all its resources as follows:

  HAS MAX
A  4   9
B  4   4
C  2   7

Eventually, B completes and we get to the following situation:

  HAS MAX
A  4   9
B  -   -
C  2   7

At this point we are stuck. We only have 4 instances of the resource free and each of the active processes need 5. 
There is no sequence that guarantees completion.

An unsafe state is not a deadlocked state. Looking at the starting point above the system can run for a while and one process can even complete. 
Furthermore, it is possible that A might release a resource before asking for any more, allowing C to complete and avoiding deadlock altogether.

The difference between a safe state and an unsafe state is that from a safe state the system can guarantee that all processes will finish. 
From an unsafe state no such guarantee can be given.

=====================
Question 2
=====================

A page can be simultaneously in two workgroups. An example of this is presented in the textbook on page 222
For shared use. A number of processes may need to be used simultaneously on a page that references the same or a code snippet
Data. For a read-only page (eg program code) the application is simpler and in the case of a page that is also used
For reading and writing (for Duma Data), for example, use copy on write.
A workgroup is defined as the set of memory pages needed to run the process at the current stage of execution. In the case where two
Processes need the same memory page, the page will be found simultaneously in two workgroups.


Question 3
=====================
The use of virtual memory may produce delay in the response of certain processes that require the withdrawal of 
pages from the secondary memory to the main memory. This delay is problematic in real-time systems that require immediate response.
When virtual memory is not supported, it is possible to make sure that resources necessary for immediate operations 
are always in memory and therefore minimize the delay that may result from the retrieval of information from the secondary memory.
Also virtual memory support is a bad idea for systems that do not need to run multiple programs at the same time
multiprogramming, e.g. embedded systems.

=====================
Question 4
=====================
To find the average run the commands in the Bash:
First, we'll mesure size all the files:
find /usr/bin -exec file {} \; | grep -i elf | cut -d: -f 1 | xargs size
We can then calculate the average and median with Win dows excel for example or Lunux statistics tools:
lets say s = X
Below is the average size of the file (in the requested library) and in the operating system on my VM,
it is considered 104700.
Given that the page size is 4B, the average size of the file is
Using the formula from the course book, we get that the optimal size for the page is:
p=SQRT (2·s·e ) = SQRT (2·104700·4) ~= 915

==============================================================================================================

/home/OU/mmn12/Unchecked/2019a-20594-12-324793900-20-1
-------Make-----------
/home/OU/mmn12/Unchecked/2019a-20594-12-324793900-20-1
gcc -Wall  -c -DFLUSH_STDOUT='setvbuf(stdout,NULL,_IOLBF,BUFSIZ);' -DFLUSH_STDERR='setvbuf(stderr,NULL,_IOLBF,BUFSIZ);' -o shell.o shell.c
gcc -Wall  shell.o -o smash -lm
2019a-20594-12-324793900-20-1_ex12.pdf
bt
ex12.exp
Grade.txt
input
jobs+bg+fg.png
Makefile
Makefile.bak
make+pipeline+fg.png
shell.c
shell.o
smash
------END Make---------

=====================================================================
------Code-----
------alloc-----
shell.c:        prog->argv = realloc(prog->argv, argcAlloced * sizeof(*prog->argv));
shell.c:    job->progs = malloc(sizeof(*job->progs));
shell.c:    job->cmdBuf = command = calloc(1, strlen(*commandPtr) + 1);
shell.c:    prog->argv = malloc(sizeof(*prog->argv) * argvAlloced);
shell.c:                    prog->argv = realloc(prog->argv, 
shell.c:            job->progs = realloc(job->progs, 
shell.c:            prog->argv = malloc(sizeof(*prog->argv) * argvAlloced);
shell.c:        job->text = malloc(strlen(*commandPtr) + 1);
shell.c:        job->text = malloc(count + 1);
shell.c:        buf = malloc(len);
shell.c:            buf = realloc(buf, len);
shell.c:        job = jobList->head = malloc(sizeof(*job));
shell.c:        job->next = malloc(sizeof(*job));
------free-----
shell.c:    int freeGlob;           /* should we globfree(&globResult)? */
shell.c:void freeJob(struct job * cmd) {
shell.c:        free(cmd->progs[i].argv);
shell.c://        if (cmd->progs[i].redirections) free(cmd->progs[i].redirections);
shell.c:        if (cmd->progs[i].freeGlob) globfree(&cmd->progs[i].globResult);
shell.c:    free(cmd->progs);
shell.c:    if (cmd->text) free(cmd->text);
shell.c:    free(cmd->cmdBuf);
shell.c:        prog->freeGlob = 1;
shell.c:       memory is freed by freeJob(). 
shell.c:    prog->freeGlob = 0;
shell.c:                    freeJob(job);
shell.c:                freeJob(job);
shell.c:            prog->freeGlob = 0;
shell.c:        freeJob(job);
shell.c:        free(buf);
shell.c:    freeJob(job); 
shell.c:    free(job);
------open-----
shell.c:        input = fopen(argv[1], "r");
shell.c:            perror("fopen");
------close-----
shell.c:                close(nextin);
shell.c:                close(nextout);
shell.c:        if (nextin != 0) close(nextin);
shell.c:        if (nextout != 1) close(nextout);
------fork-----
shell.c:    /* handle built-ins here -- we don't fork() so we can't background
shell.c:        if (!(newJob.progs[i].pid = fork())) {
------wait-----
shell.c:#include <sys/wait.h>
shell.c:        /* we don't wait for background jobs to return -- append it 
shell.c:    while ((childpid = waitpid(-1, &status, WNOHANG | WUNTRACED)) > 0) {
shell.c:        perror("waitpid");
shell.c:            /* a job is running in the foreground; wait for it */
shell.c:            waitpid(jobList.fg->progs[i].pid, &status, WUNTRACED);
------dup-----
shell.c:                dup2(nextin, 0);
shell.c:                dup2(nextout, 1);
------signal-----
shell.c:#include <signal.h>
shell.c:            signal(SIGTTOU, SIG_DFL);
shell.c:	    signal (SIGINT, SIG_DFL);
shell.c:	    signal (SIGQUIT, SIG_DFL);
shell.c:	    signal (SIGTSTP, SIG_DFL);
shell.c:	    signal (SIGTTIN, SIG_DFL);
shell.c:	    signal (SIGTTOU, SIG_DFL);
shell.c:	    signal (SIGCHLD, SIG_DFL);
shell.c:    signal (SIGINT, SIG_IGN);
shell.c:    signal (SIGQUIT, SIG_IGN);
shell.c:    signal (SIGTSTP, SIG_IGN);
shell.c:    signal (SIGTTIN, SIG_IGN);
shell.c:    signal (SIGTTOU, SIG_IGN);  

=====================================================================

---------RUN----------

ls


ps | wc -l


find ../../.. -name Makefile -type f -print 


find ../../.. -name Makefile -type f -print |cat


cat /etc/passwd | wc -l


cat /etc/passwd | wc -c


chown -R root:root /tmp 


cd ..


ls


cd -


ls


pwd


cd .


someErr


someErr|cat


ls -l|someErr


cd someErr


exit





------END-RUN----------
